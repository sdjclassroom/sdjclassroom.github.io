{"version":3,"sources":["../src/compress.ts","../src/compressInMemory.ts","../src/setup.ts","../src/index.ts"],"sourcesContent":["/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport fs from \"node:fs\";\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\nimport { mkdirp } from \"mkdirp\";\n\n/**\n * Run compressor.\n * @param settings Settings\n */\nconst compress = (settings: Settings): Promise<string> | string => {\n    if (typeof settings.compressor !== \"function\") {\n        throw new Error(\n            \"compressor should be a function, maybe you forgot to install the compressor\"\n        );\n    }\n\n    if (settings.output) {\n        createDirectory(settings.output);\n    }\n\n    if (Array.isArray(settings.output)) {\n        return settings.sync\n            ? compressArrayOfFilesSync(settings)\n            : compressArrayOfFilesAsync(settings);\n    }\n    return utils.compressSingleFile(settings);\n};\n\n/**\n * Compress an array of files in sync.\n * @param settings Settings\n */\nconst compressArrayOfFilesSync = (settings: Settings): any => {\n    return (\n        Array.isArray(settings.input) &&\n        settings.input.forEach((input, index) => {\n            const content = utils.getContentFromFiles(input);\n            return utils.runSync({ settings, content, index });\n        })\n    );\n};\n\n/**\n * Compress an array of files in async.\n * @param settings Settings\n */\nconst compressArrayOfFilesAsync = (\n    settings: Settings\n): Promise<string | void> => {\n    let sequence: Promise<string | void> = Promise.resolve();\n    Array.isArray(settings.input) &&\n        settings.input.forEach((input, index) => {\n            const content = utils.getContentFromFiles(input);\n            sequence = sequence.then(() =>\n                utils.runAsync({ settings, content, index })\n            );\n        });\n    return sequence;\n};\n\n/**\n * Create folder of the target file.\n * @param file Full path of the file\n */\nconst createDirectory = (file: string) => {\n    if (Array.isArray(file)) {\n        file = file[0];\n    }\n    const dir = file?.substr(0, file.lastIndexOf(\"/\"));\n    if (!dir) {\n        return;\n    }\n    if (!fs.statSync(dir).isDirectory()) {\n        mkdirp.sync(dir);\n    }\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compress };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\n\n/**\n * Run compressor.\n * @param settings Settings\n */\nconst compressInMemory = (settings: Settings): Promise<string> | string => {\n    if (typeof settings.compressor !== \"function\") {\n        throw new Error(\n            \"compressor should be a function, maybe you forgot to install the compressor\"\n        );\n    }\n\n    return utils.compressSingleFile(settings);\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compressInMemory };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport path from \"node:path\";\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\nimport { globSync } from \"glob\";\n\n/**\n * Default settings.\n */\nconst defaultSettings = {\n    sync: false,\n    options: {},\n    buffer: 1000 * 1024,\n    callback: false,\n};\n\n/**\n * Run setup.\n * @param inputSettings Settings from user input\n */\nconst setup = (inputSettings: Settings) => {\n    let settings: Settings = Object.assign(\n        utils.clone(defaultSettings),\n        inputSettings\n    );\n\n    // In memory\n    if (settings.content) {\n        checkMandatoriesMemoryContent(inputSettings);\n        return settings;\n    }\n\n    checkMandatories(inputSettings);\n\n    if (settings.input) {\n        settings = Object.assign(\n            settings,\n            wildcards(settings.input, settings.publicFolder)\n        );\n    }\n    if (settings.input && settings.output) {\n        settings = Object.assign(\n            settings,\n            checkOutput(\n                settings.input,\n                settings.output,\n                settings.publicFolder,\n                settings.replaceInPlace\n            )\n        );\n    }\n    if (settings.input && settings.publicFolder) {\n        settings = Object.assign(\n            settings,\n            setPublicFolder(settings.input, settings.publicFolder)\n        );\n    }\n\n    return settings;\n};\n\n/**\n * Check the output path, searching for $1\n * if exist, returns the path replacing $1 by file name\n * @param input Path file\n * @param output Path to the output file\n * @param publicFolder Path to the public folder\n * @param replaceInPlace True to replace file in same folder\n */\nconst checkOutput = (\n    input: string | string[],\n    output: string,\n    publicFolder?: string,\n    replaceInPlace?: boolean\n) => {\n    const reg = /\\$1/;\n    if (reg.test(output)) {\n        if (Array.isArray(input)) {\n            const outputMin = input.map((file) =>\n                utils.setFileNameMin(\n                    file,\n                    output,\n                    replaceInPlace ? undefined : publicFolder,\n                    replaceInPlace\n                )\n            );\n            return { output: outputMin };\n        }\n        return {\n            output: utils.setFileNameMin(\n                input,\n                output,\n                replaceInPlace ? undefined : publicFolder,\n                replaceInPlace\n            ),\n        };\n    }\n};\n\n/**\n * Handle wildcards in a path, get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcards = (input: string | string[], publicFolder?: string) => {\n    // If it's a string\n    if (!Array.isArray(input)) {\n        return wildcardsString(input, publicFolder);\n    }\n\n    return wildcardsArray(input, publicFolder);\n};\n\n/**\n * Handle wildcards in a path (string only), get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcardsString = (input: string, publicFolder?: string) => {\n    const output: { input?: string[] } = {};\n\n    if (input.indexOf(\"*\") > -1) {\n        output.input = getFilesFromWildcards(input, publicFolder);\n    }\n\n    return output;\n};\n\n/**\n * Handle wildcards in a path (array only), get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcardsArray = (input: string[], publicFolder?: string) => {\n    const output: { input?: string[] } = {};\n    let isWildcardsPresent = false;\n\n    output.input = input;\n\n    // Transform all wildcards to path file\n    const inputWithPublicFolder = input.map((item) => {\n        if (item.indexOf(\"*\") > -1) {\n            isWildcardsPresent = true;\n        }\n        return (publicFolder || \"\") + item;\n    });\n\n    if (isWildcardsPresent) {\n        output.input = globSync(inputWithPublicFolder);\n    }\n\n    // Remove all wildcards from array\n    for (let i = 0; i < output.input.length; i++) {\n        if (output.input[i].indexOf(\"*\") > -1) {\n            output.input.splice(i, 1);\n\n            i--;\n        }\n    }\n\n    return output;\n};\n\n/**\n * Get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst getFilesFromWildcards = (input: string, publicFolder?: string) => {\n    let output: string[] = [];\n\n    if (input.indexOf(\"*\") > -1) {\n        output = globSync((publicFolder || \"\") + input);\n    }\n\n    return output;\n};\n\n/**\n * Prepend the public folder to each file.\n * @param input Path to file(s)\n * @param publicFolder Path to the public folder\n */\nconst setPublicFolder = (input: string | string[], publicFolder: string) => {\n    const output: { input?: string | string[] } = {};\n\n    if (typeof publicFolder !== \"string\") {\n        return output;\n    }\n\n    publicFolder = path.normalize(publicFolder);\n\n    if (Array.isArray(input)) {\n        output.input = input.map((item) => {\n            // Check if publicFolder is already in path\n            if (path.normalize(item).indexOf(publicFolder) > -1) {\n                return item;\n            }\n            return path.normalize(publicFolder + item);\n        });\n        return output;\n    }\n\n    input = path.normalize(input);\n\n    // Check if publicFolder is already in path\n    if (input.indexOf(publicFolder) > -1) {\n        output.input = input;\n        return output;\n    }\n\n    output.input = path.normalize(publicFolder + input);\n\n    return output;\n};\n\n/**\n * Check if some settings are here.\n * @param settings Settings\n */\nconst checkMandatories = (settings: Settings) => {\n    [\"compressor\", \"input\", \"output\"].forEach((item: string) =>\n        mandatory(item, settings)\n    );\n};\n\n/**\n * Check if some settings are here for memory content.\n * @param settings Settings\n */\nconst checkMandatoriesMemoryContent = (settings: Settings) => {\n    [\"compressor\", \"content\"].forEach((item: string) =>\n        mandatory(item, settings)\n    );\n};\n\n/**\n * Check if the setting exist.\n * @param setting Setting\n * @param settings Settings\n */\nconst mandatory = (setting: string, settings: { [key: string]: any }) => {\n    if (!settings[setting]) {\n        throw new Error(`${setting} is mandatory.`);\n    }\n};\n\n/**\n * Expose `setup()`.\n */\nexport { setup };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport type { Settings } from \"@node-minify/types\";\nimport { compress } from \"./compress\";\nimport { compressInMemory } from \"./compressInMemory\";\nimport { setup } from \"./setup\";\n\n/**\n * Run node-minify.\n * @param settings Settings from user input\n */\nconst minify = (settings: Settings) => {\n    return new Promise((resolve, reject) => {\n        const method: any = settings.content ? compressInMemory : compress;\n        settings = setup(settings);\n        if (!settings.sync) {\n            method(settings)\n                .then((minified: string) => {\n                    if (settings.callback) {\n                        settings.callback(null, minified);\n                    }\n                    resolve(minified);\n                })\n                .catch((err: Error) => {\n                    if (settings.callback) {\n                        settings.callback(err);\n                    }\n                    reject(err);\n                });\n        } else {\n            const minified: string = method(settings);\n            if (settings.callback) {\n                settings.callback(null, minified);\n            }\n            resolve(minified);\n        }\n    });\n};\n\n/**\n * Expose `minify()`.\n */\nminify.default = minify;\nexport = minify;\n"],"mappings":"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","names":["utils","utils"]}