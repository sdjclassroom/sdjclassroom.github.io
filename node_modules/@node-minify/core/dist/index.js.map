{"version":3,"sources":["../src/compress.ts","../src/compressInMemory.ts","../src/setup.ts","../src/index.ts"],"sourcesContent":["/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport fs from \"node:fs\";\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\nimport { mkdirp } from \"mkdirp\";\n\n/**\n * Run compressor.\n * @param settings Settings\n */\nconst compress = (settings: Settings): Promise<string> | string => {\n    if (typeof settings.compressor !== \"function\") {\n        throw new Error(\n            \"compressor should be a function, maybe you forgot to install the compressor\"\n        );\n    }\n\n    if (settings.output) {\n        createDirectory(settings.output);\n    }\n\n    if (Array.isArray(settings.output)) {\n        return settings.sync\n            ? compressArrayOfFilesSync(settings)\n            : compressArrayOfFilesAsync(settings);\n    }\n    return utils.compressSingleFile(settings);\n};\n\n/**\n * Compress an array of files in sync.\n * @param settings Settings\n */\nconst compressArrayOfFilesSync = (settings: Settings): any => {\n    return (\n        Array.isArray(settings.input) &&\n        settings.input.forEach((input, index) => {\n            const content = utils.getContentFromFiles(input);\n            return utils.runSync({ settings, content, index });\n        })\n    );\n};\n\n/**\n * Compress an array of files in async.\n * @param settings Settings\n */\nconst compressArrayOfFilesAsync = (\n    settings: Settings\n): Promise<string | void> => {\n    let sequence: Promise<string | void> = Promise.resolve();\n    Array.isArray(settings.input) &&\n        settings.input.forEach((input, index) => {\n            const content = utils.getContentFromFiles(input);\n            sequence = sequence.then(() =>\n                utils.runAsync({ settings, content, index })\n            );\n        });\n    return sequence;\n};\n\n/**\n * Create folder of the target file.\n * @param file Full path of the file\n */\nconst createDirectory = (file: string) => {\n    if (Array.isArray(file)) {\n        file = file[0];\n    }\n    const dir = file?.substr(0, file.lastIndexOf(\"/\"));\n    if (!dir) {\n        return;\n    }\n    if (!fs.statSync(dir).isDirectory()) {\n        mkdirp.sync(dir);\n    }\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compress };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\n\n/**\n * Run compressor.\n * @param settings Settings\n */\nconst compressInMemory = (settings: Settings): Promise<string> | string => {\n    if (typeof settings.compressor !== \"function\") {\n        throw new Error(\n            \"compressor should be a function, maybe you forgot to install the compressor\"\n        );\n    }\n\n    return utils.compressSingleFile(settings);\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compressInMemory };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport path from \"node:path\";\nimport type { Settings } from \"@node-minify/types\";\nimport { utils } from \"@node-minify/utils\";\nimport { globSync } from \"glob\";\n\n/**\n * Default settings.\n */\nconst defaultSettings = {\n    sync: false,\n    options: {},\n    buffer: 1000 * 1024,\n    callback: false,\n};\n\n/**\n * Run setup.\n * @param inputSettings Settings from user input\n */\nconst setup = (inputSettings: Settings) => {\n    let settings: Settings = Object.assign(\n        utils.clone(defaultSettings),\n        inputSettings\n    );\n\n    // In memory\n    if (settings.content) {\n        checkMandatoriesMemoryContent(inputSettings);\n        return settings;\n    }\n\n    checkMandatories(inputSettings);\n\n    if (settings.input) {\n        settings = Object.assign(\n            settings,\n            wildcards(settings.input, settings.publicFolder)\n        );\n    }\n    if (settings.input && settings.output) {\n        settings = Object.assign(\n            settings,\n            checkOutput(\n                settings.input,\n                settings.output,\n                settings.publicFolder,\n                settings.replaceInPlace\n            )\n        );\n    }\n    if (settings.input && settings.publicFolder) {\n        settings = Object.assign(\n            settings,\n            setPublicFolder(settings.input, settings.publicFolder)\n        );\n    }\n\n    return settings;\n};\n\n/**\n * Check the output path, searching for $1\n * if exist, returns the path replacing $1 by file name\n * @param input Path file\n * @param output Path to the output file\n * @param publicFolder Path to the public folder\n * @param replaceInPlace True to replace file in same folder\n */\nconst checkOutput = (\n    input: string | string[],\n    output: string,\n    publicFolder?: string,\n    replaceInPlace?: boolean\n) => {\n    const reg = /\\$1/;\n    if (reg.test(output)) {\n        if (Array.isArray(input)) {\n            const outputMin = input.map((file) =>\n                utils.setFileNameMin(\n                    file,\n                    output,\n                    replaceInPlace ? undefined : publicFolder,\n                    replaceInPlace\n                )\n            );\n            return { output: outputMin };\n        }\n        return {\n            output: utils.setFileNameMin(\n                input,\n                output,\n                replaceInPlace ? undefined : publicFolder,\n                replaceInPlace\n            ),\n        };\n    }\n};\n\n/**\n * Handle wildcards in a path, get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcards = (input: string | string[], publicFolder?: string) => {\n    // If it's a string\n    if (!Array.isArray(input)) {\n        return wildcardsString(input, publicFolder);\n    }\n\n    return wildcardsArray(input, publicFolder);\n};\n\n/**\n * Handle wildcards in a path (string only), get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcardsString = (input: string, publicFolder?: string) => {\n    const output: { input?: string[] } = {};\n\n    if (input.indexOf(\"*\") > -1) {\n        output.input = getFilesFromWildcards(input, publicFolder);\n    }\n\n    return output;\n};\n\n/**\n * Handle wildcards in a path (array only), get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst wildcardsArray = (input: string[], publicFolder?: string) => {\n    const output: { input?: string[] } = {};\n    let isWildcardsPresent = false;\n\n    output.input = input;\n\n    // Transform all wildcards to path file\n    const inputWithPublicFolder = input.map((item) => {\n        if (item.indexOf(\"*\") > -1) {\n            isWildcardsPresent = true;\n        }\n        return (publicFolder || \"\") + item;\n    });\n\n    if (isWildcardsPresent) {\n        output.input = globSync(inputWithPublicFolder);\n    }\n\n    // Remove all wildcards from array\n    for (let i = 0; i < output.input.length; i++) {\n        if (output.input[i].indexOf(\"*\") > -1) {\n            output.input.splice(i, 1);\n\n            i--;\n        }\n    }\n\n    return output;\n};\n\n/**\n * Get the real path of each files.\n * @param input Path with wildcards\n * @param publicFolder Path to the public folder\n */\nconst getFilesFromWildcards = (input: string, publicFolder?: string) => {\n    let output: string[] = [];\n\n    if (input.indexOf(\"*\") > -1) {\n        output = globSync((publicFolder || \"\") + input);\n    }\n\n    return output;\n};\n\n/**\n * Prepend the public folder to each file.\n * @param input Path to file(s)\n * @param publicFolder Path to the public folder\n */\nconst setPublicFolder = (input: string | string[], publicFolder: string) => {\n    const output: { input?: string | string[] } = {};\n\n    if (typeof publicFolder !== \"string\") {\n        return output;\n    }\n\n    publicFolder = path.normalize(publicFolder);\n\n    if (Array.isArray(input)) {\n        output.input = input.map((item) => {\n            // Check if publicFolder is already in path\n            if (path.normalize(item).indexOf(publicFolder) > -1) {\n                return item;\n            }\n            return path.normalize(publicFolder + item);\n        });\n        return output;\n    }\n\n    input = path.normalize(input);\n\n    // Check if publicFolder is already in path\n    if (input.indexOf(publicFolder) > -1) {\n        output.input = input;\n        return output;\n    }\n\n    output.input = path.normalize(publicFolder + input);\n\n    return output;\n};\n\n/**\n * Check if some settings are here.\n * @param settings Settings\n */\nconst checkMandatories = (settings: Settings) => {\n    [\"compressor\", \"input\", \"output\"].forEach((item: string) =>\n        mandatory(item, settings)\n    );\n};\n\n/**\n * Check if some settings are here for memory content.\n * @param settings Settings\n */\nconst checkMandatoriesMemoryContent = (settings: Settings) => {\n    [\"compressor\", \"content\"].forEach((item: string) =>\n        mandatory(item, settings)\n    );\n};\n\n/**\n * Check if the setting exist.\n * @param setting Setting\n * @param settings Settings\n */\nconst mandatory = (setting: string, settings: { [key: string]: any }) => {\n    if (!settings[setting]) {\n        throw new Error(`${setting} is mandatory.`);\n    }\n};\n\n/**\n * Expose `setup()`.\n */\nexport { setup };\n","/*!\n * node-minify\n * Copyright(c) 2011-2024 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport type { Settings } from \"@node-minify/types\";\nimport { compress } from \"./compress\";\nimport { compressInMemory } from \"./compressInMemory\";\nimport { setup } from \"./setup\";\n\n/**\n * Run node-minify.\n * @param settings Settings from user input\n */\nconst minify = (settings: Settings) => {\n    return new Promise((resolve, reject) => {\n        const method: any = settings.content ? compressInMemory : compress;\n        settings = setup(settings);\n        if (!settings.sync) {\n            method(settings)\n                .then((minified: string) => {\n                    if (settings.callback) {\n                        settings.callback(null, minified);\n                    }\n                    resolve(minified);\n                })\n                .catch((err: Error) => {\n                    if (settings.callback) {\n                        settings.callback(err);\n                    }\n                    reject(err);\n                });\n        } else {\n            const minified: string = method(settings);\n            if (settings.callback) {\n                settings.callback(null, minified);\n            }\n            resolve(minified);\n        }\n    });\n};\n\n/**\n * Expose `minify()`.\n */\nminify.default = minify;\nexport = minify;\n"],"mappings":"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","names":["fs","import_utils","import_utils","path"]}